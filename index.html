<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RedKit Proxy Dashboard</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    body { background-color: #0f0f0f; color: #e5e5e5; font-family: monospace; }
    .table-row:hover { background-color: #222; cursor: pointer; }
    .badge { padding: 0.2rem 0.5rem; border-radius: 0.25rem; font-weight: bold; color: white; }
    .status-2xx { background-color: #10b981; }
    .status-3xx { background-color: #3b82f6; }
    .status-4xx { background-color: #f59e0b; }
    .status-5xx { background-color: #ef4444; }
    pre { white-space: pre-wrap; word-wrap: break-word; }
    .tab-btn { transition: all 0.2s; }
    .tab-btn.active { background-color: #ef4444; color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    textarea { resize: vertical; font-family: monospace; }
    .connection-status {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
    }
    .connection-status.connected { background-color: #10b981; }
    .connection-status.disconnected { background-color: #ef4444; }
    .connection-status.connecting { background-color: #f59e0b; }
    .intercept-table { width: 100%; border-collapse: collapse; }
    .intercept-table th { 
        background: #1a1a1a; 
        padding: 8px; 
        text-align: left; 
        border-bottom: 2px solid #333;
        position: sticky;
        top: 0;
    }
    .intercept-table td { 
        padding: 8px; 
        border-bottom: 1px solid #333;
    }
    .intercept-table tr:hover { background: #2a2a2a; }
    .intercept-table tr.selected { background: #3a3a3a; }
    .btn-action {
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        border: none;
        margin-right: 8px;
    }
    .btn-forward { background-color: #10b981; color: white; }
    .btn-forward:hover { background-color: #059669; }
    .btn-drop { background-color: #ef4444; color: white; }
    .btn-drop:hover { background-color: #dc2626; }
    .btn-forward-all { background-color: #3b82f6; color: white; }
    .btn-forward-all:hover { background-color: #2563eb; }
    .btn-drop-all { background-color: #7c3aed; color: white; }
    .btn-drop-all:hover { background-color: #6d28d9; }
    .btn-intercept-toggle { background-color: #f59e0b; color: white; }
    .btn-intercept-toggle.active { background-color: #10b981; }
    .intercepting { animation: pulse 2s infinite; }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    .queue-badge {
        background: #ef4444;
        color: white;
        border-radius: 50%;
        padding: 2px 6px;
        font-size: 10px;
        margin-left: 5px;
    }
    .split-pane {
        display: flex;
        flex-direction: column;
        height: calc(100% - 60px);
    }
    .top-pane {
        flex: 1;
        overflow: auto;
        border-bottom: 2px solid #333;
    }
    .bottom-pane {
        height: 40%;
        display: flex;
        flex-direction: column;
    }
</style>
</head>
<body class="p-6">

<div id="connection-status" class="connection-status connecting">Connecting...</div>

<h1 class="text-3xl font-bold mb-4">RedKit Proxy Dashboard</h1>

<!-- Navigation Tabs -->
<div class="flex gap-2 mb-4">
    <button onclick="showTab('interceptor')" class="tab-btn active px-4 py-2 rounded bg-gray-700 hover:bg-gray-600" id="tab-interceptor">
        Interceptor <span id="queue-count" class="queue-badge hidden">0</span>
    </button>
    <button onclick="showTab('history')" class="tab-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600" id="tab-history">HTTP History</button>
    <button onclick="showTab('repeater')" class="tab-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600" id="tab-repeater">Repeater</button>
    <button onclick="showTab('intruder')" class="tab-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600" id="tab-intruder">Intruder</button>
</div>

<!-- INTERCEPTOR TAB -->
<div id="content-interceptor" class="tab-content active">
    <div class="h-[75vh] flex flex-col">
        <!-- Intercept Controls -->
        <div class="bg-[#141414] rounded-xl p-4 mb-4">
            <div class="flex justify-between items-center">
                <div class="flex gap-2">
                    <button onclick="toggleIntercept()" id="intercept-toggle-btn" class="btn-action btn-intercept-toggle">
                        Intercept is OFF
                    </button>
                    <span id="intercept-status" class="text-sm text-gray-400 ml-2"></span>
                </div>
                <div class="flex gap-2">
                    <button onclick="markForResponseIntercept()" id="intercept-response-btn" class="btn-action btn-intercept-toggle" style="background-color: #8b5cf6;" disabled>
                        Intercept Response
                    </button>
                    <button onclick="forwardRequest()" class="btn-action btn-forward">Forward</button>
                    <button onclick="dropRequest()" class="btn-action btn-drop">Drop</button>
                    <button onclick="forwardAll()" class="btn-action btn-forward-all">Forward All</button>
                    <button onclick="dropAll()" class="btn-action btn-drop-all">Drop All</button>
                </div>
            </div>
            <div class="mt-2 text-xs text-gray-500">
                Queue: <span id="queue-size">0</span> requests waiting
                <span id="response-intercept-status" class="ml-4 text-purple-400"></span>
            </div>
        </div>

        <!-- Split Pane: Table (top) and Editor (bottom) -->
        <div class="split-pane bg-[#141414] rounded-xl">
            <!-- Top: Intercept Table (most recent at bottom) -->
            <div class="top-pane p-4">
                <table class="intercept-table text-sm">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Method</th>
                            <th>Host</th>
                            <th>URL</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="intercept-table-body">
                        <tr><td colspan="5" class="text-center text-gray-500 py-8">No intercepted requests</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Bottom: Request/Response Editor (Split view like Burp) -->
            <div class="bottom-pane border-t border-gray-700">
                <!-- Single pane view (for editing request or response only) -->
                <div id="single-editor-pane" class="p-4 h-full flex flex-col">
                    <div class="flex justify-between items-center mb-2">
                        <h3 id="single-editor-title" class="text-sm font-semibold text-gray-400">Request Editor (Raw)</h3>
                        <button onclick="updateInterceptedRequest()" class="px-3 py-1 bg-blue-600 rounded hover:bg-blue-500 text-xs">Update</button>
                    </div>
                    <textarea id="intercept-editor" class="w-full flex-1 p-3 rounded bg-[#1f1f1f] text-sm font-mono"
                        placeholder="GET /path HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

key=value"></textarea>
                </div>

                <!-- Split pane view (for response interception - request read-only, response editable) -->
                <div id="split-editor-pane" class="hidden h-full flex">
                    <!-- Left: Request (Read-only) -->
                    <div class="w-1/2 p-4 border-r border-gray-700 flex flex-col">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-semibold text-gray-400">Request (Read-Only)</h3>
                        </div>
                        <textarea id="intercept-request-view" class="w-full flex-1 p-3 rounded bg-[#1a1a1a] text-sm font-mono text-gray-400" readonly></textarea>
                    </div>
                    <!-- Right: Response (Editable) -->
                    <div class="w-1/2 p-4 flex flex-col">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-semibold text-gray-400">Response (Editable)</h3>
                            <button onclick="updateInterceptedResponse()" class="px-3 py-1 bg-blue-600 rounded hover:bg-blue-500 text-xs">Update Response</button>
                        </div>
                        <textarea id="intercept-response-editor" class="w-full flex-1 p-3 rounded bg-[#1f1f1f] text-sm font-mono"
                            placeholder="HTTP/1.1 200 OK
Content-Type: text/html

Response body..."></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- HTTP HISTORY TAB -->
<div id="content-history" class="tab-content">
    <div class="flex gap-4 h-[75vh]">
        <!-- Left: History List -->
        <div class="w-2/5 bg-[#141414] rounded-xl p-4 shadow flex flex-col">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-semibold">HTTP History</h2>
                <button onclick="clearHistory()" class="px-2 py-1 bg-red-600 rounded hover:bg-red-500 text-xs">Clear</button>
            </div>
            <input id="history-search" placeholder="Search URL..." class="w-full mb-3 p-2 rounded bg-[#1f1f1f] text-sm" oninput="filterHistory()" />
            <div class="flex-1 overflow-auto">
                <table class="w-full text-sm">
                    <thead class="text-gray-400 border-b border-gray-700 sticky top-0 bg-[#141414]">
                        <tr><th class="p-2 text-left">ID</th><th class="p-2 text-left">Method</th><th class="p-2 text-left">Status</th><th class="p-2 text-left">URL</th></tr>
                    </thead>
                    <tbody id="history-table"></tbody>
                </table>
            </div>
        </div>

        <!-- Right: Request/Response Details -->
        <div class="w-3/5 flex flex-col gap-4">
            <!-- Request -->
            <div class="bg-[#141414] rounded-xl p-4 shadow flex-1 overflow-auto">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-semibold text-gray-400">Request</h3>
                    <button onclick="sendHistoryToRepeater()" class="px-2 py-1 bg-blue-600 rounded hover:bg-blue-500 text-xs">Send to Repeater</button>
                </div>
                <pre id="history-request-headers" class="bg-[#1f1f1f] p-2 rounded text-xs mb-2">Select a request...</pre>
                <pre id="history-request-body" class="bg-[#1f1f1f] p-2 rounded text-xs">No request selected</pre>
            </div>

            <!-- Response -->
            <div class="bg-[#141414] rounded-xl p-4 shadow flex-1 overflow-auto">
                <h3 class="text-sm font-semibold text-gray-400 mb-2">Response</h3>
                <pre id="history-response-headers" class="bg-[#1f1f1f] p-2 rounded text-xs mb-2">Select a request...</pre>
                <pre id="history-response-body" class="bg-[#1f1f1f] p-2 rounded text-xs">No response selected</pre>
            </div>
        </div>
    </div>
</div>

<!-- REPEATER TAB -->
<div id="content-repeater" class="tab-content">
    <div class="flex gap-4 h-[75vh]">
        <div class="w-1/2 bg-[#141414] rounded-xl p-4 shadow flex flex-col">
            <h2 class="text-xl font-semibold mb-3">Request</h2>
            <div class="flex gap-2 mb-3">
                <select id="repeater-method" class="p-2 rounded bg-[#1f1f1f] w-24 text-sm">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="DELETE">DELETE</option>
                    <option value="PATCH">PATCH</option>
                    <option value="HEAD">HEAD</option>
                    <option value="OPTIONS">OPTIONS</option>
                </select>
                <input id="repeater-url" placeholder="https://example.com/api/endpoint" class="flex-1 p-2 rounded bg-[#1f1f1f] text-sm" />
            </div>
            <label class="text-gray-400 text-sm mb-1">Headers (JSON)</label>
            <textarea id="repeater-headers" class="p-2 rounded bg-[#1f1f1f] h-24 mb-3 font-mono text-sm">{
  "Content-Type": "application/json"
}</textarea>
            <label class="text-gray-400 text-sm mb-1">Body</label>
            <textarea id="repeater-body" class="p-2 rounded bg-[#1f1f1f] flex-1 font-mono text-sm" placeholder="Request body..."></textarea>
            <div class="flex gap-2 mt-3">
                <button onclick="sendRepeaterRequest()" class="flex-1 p-2 bg-green-600 rounded hover:bg-green-500 font-bold text-sm">Send</button>
                <button onclick="clearRepeater()" class="p-2 bg-gray-600 rounded hover:bg-gray-500 text-sm">Clear</button>
            </div>
        </div>

        <div class="w-1/2 bg-[#141414] rounded-xl p-4 shadow flex flex-col">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-xl font-semibold">Response</h2>
                <div id="repeater-status" class="text-sm"></div>
            </div>
            <div id="repeater-info" class="flex gap-4 mb-3 text-sm text-gray-400">
                <span>Status: <span id="repeater-status-code" class="text-white">-</span></span>
                <span>Time: <span id="repeater-time" class="text-white">-</span></span>
                <span>Size: <span id="repeater-size" class="text-white">-</span></span>
            </div>
            <div class="flex-1 overflow-auto">
                <pre id="repeater-response" class="bg-[#1f1f1f] p-3 rounded text-xs"></pre>
            </div>
        </div>
    </div>
</div>

<!-- INTRUDER TAB -->
<div id="content-intruder" class="tab-content">
    <div class="flex gap-4 h-[75vh]">
        <div class="w-1/3 bg-[#141414] rounded-xl p-4 shadow flex flex-col overflow-auto">
            <h2 class="text-xl font-semibold mb-3">Attack Configuration</h2>

            <label class="text-gray-400 text-sm mb-1">Attack Type</label>
            <select id="intruder-attack-type" class="p-2 rounded bg-[#1f1f1f] mb-3 text-sm">
                <option value="sniper">Sniper - Single position at a time</option>
                <option value="battering_ram">Battering Ram - Same payload everywhere</option>
            </select>

            <label class="text-gray-400 text-sm mb-1">Method</label>
            <select id="intruder-method" class="p-2 rounded bg-[#1f1f1f] mb-3 w-full text-sm">
                <option value="GET">GET</option>
                <option value="POST">POST</option>
                <option value="PUT">PUT</option>
                <option value="DELETE">DELETE</option>
            </select>

            <label class="text-gray-400 text-sm mb-1">Target URL (use &sect; for positions)</label>
            <input id="intruder-url" placeholder="https://target.com/user/&sect;1&sect;" class="p-2 rounded bg-[#1f1f1f] mb-3 text-sm" />

            <label class="text-gray-400 text-sm mb-1">Headers (JSON)</label>
            <textarea id="intruder-headers" class="p-2 rounded bg-[#1f1f1f] h-20 mb-3 font-mono text-sm">{}</textarea>

            <label class="text-gray-400 text-sm mb-1">Body (use &sect; for positions)</label>
            <textarea id="intruder-body" class="p-2 rounded bg-[#1f1f1f] h-20 mb-3 font-mono text-sm" placeholder="username=&sect;admin&sect;&amp;password=&sect;pass&sect;"></textarea>

            <label class="text-gray-400 text-sm mb-1">Payloads (one per line)</label>
            <textarea id="intruder-payloads" class="p-2 rounded bg-[#1f1f1f] flex-1 font-mono text-sm" placeholder="admin&#10;root&#10;user&#10;test"></textarea>

            <div class="flex gap-2 mt-3">
                <select id="intruder-preset" class="p-2 rounded bg-[#1f1f1f] flex-1 text-sm" onchange="loadPayloadPreset()">
                    <option value="">Load Preset...</option>
                    <option value="passwords">Common Passwords</option>
                    <option value="usernames">Common Usernames</option>
                    <option value="sqli">SQL Injection</option>
                    <option value="xss">XSS Payloads</option>
                    <option value="path_traversal">Path Traversal</option>
                </select>
                <input id="intruder-threads" type="number" value="10" min="1" max="50" class="p-2 rounded bg-[#1f1f1f] w-20 text-sm" title="Threads" />
            </div>

            <div class="flex gap-2 mt-3">
                <button onclick="startIntruderAttack()" id="intruder-start-btn" class="flex-1 p-2 bg-red-600 rounded hover:bg-red-500 font-bold text-sm">Start Attack</button>
                <button onclick="stopIntruderAttack()" class="p-2 bg-gray-600 rounded hover:bg-gray-500 text-sm">Stop</button>
            </div>
        </div>

        <div class="w-2/3 bg-[#141414] rounded-xl p-4 shadow flex flex-col">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-xl font-semibold">Results</h2>
                <div id="intruder-progress" class="text-sm text-gray-400"></div>
            </div>

            <div class="flex-1 overflow-auto mb-3">
                <table class="w-full text-sm">
                    <thead class="text-gray-400 border-b border-gray-700 sticky top-0 bg-[#141414]">
                        <tr>
                            <th class="p-2 text-left">#</th>
                            <th class="p-2 text-left">Payload</th>
                            <th class="p-2 text-left">Status</th>
                            <th class="p-2 text-left">Length</th>
                            <th class="p-2 text-left">Time</th>
                        </tr>
                    </thead>
                    <tbody id="intruder-results"></tbody>
                </table>
            </div>

            <div class="bg-[#1f1f1f] rounded p-3">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-gray-400 text-sm">Response Preview</span>
                    <button onclick="copyContent('intruder-response-preview')" class="text-xs p-1 bg-gray-600 rounded">Copy</button>
                </div>
                <pre id="intruder-response-preview" class="text-xs max-h-40 overflow-auto"></pre>
            </div>

            <div id="intruder-summary" class="mt-3 p-3 bg-[#1f1f1f] rounded text-sm hidden">
                <span class="font-bold">Summary:</span>
                <span id="intruder-summary-text"></span>
            </div>
        </div>
    </div>
</div>

<script>
// WebSocket Connection
let ws = null;
let reconnectInterval = null;
let intruderResults = [];

// Interceptor state
let interceptEnabled = false;
let responseInterceptEnabled = false;
let interceptQueue = [];
let selectedInterceptIndex = -1;
let markedForResponseIntercept = new Set(); // Track requests marked for response interception

// History state
let historyData = [];
let selectedHistoryId = null;

function updateConnectionStatus(status) {
    const el = document.getElementById('connection-status');
    el.className = 'connection-status ' + status;
    if (status === 'connected') el.textContent = 'Connected';
    else if (status === 'disconnected') el.textContent = 'Disconnected';
    else if (status === 'connecting') el.textContent = 'Connecting...';
}

function connectWebSocket() {
    updateConnectionStatus('connecting');
    
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
    
    ws.onopen = () => {
        console.log('WebSocket connected');
        updateConnectionStatus('connected');
        if (reconnectInterval) {
            clearInterval(reconnectInterval);
            reconnectInterval = null;
        }
        // Request initial data
        sendMessage({action: 'get_history'});
    };
    
    ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        handleWebSocketMessage(msg);
    };
    
    ws.onclose = () => {
        console.log('WebSocket disconnected');
        updateConnectionStatus('disconnected');
        if (!reconnectInterval) {
            reconnectInterval = setInterval(() => {
                console.log('Attempting to reconnect...');
                connectWebSocket();
            }, 3000);
        }
    };
    
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateConnectionStatus('disconnected');
    };
}

function sendMessage(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    } else {
        console.error('WebSocket not connected');
    }
}

function handleWebSocketMessage(msg) {
    const type = msg.type;
    
    // INTERCEPTOR
    if (type === 'intercepted_request') {
        // Check if this request is already in the queue (avoid duplicates)
        const existingIndex = interceptQueue.findIndex(r => r.id === msg.id);
        if (existingIndex >= 0) {
            return; // Already exists, ignore
        }
        
        // Add new request to the END of queue (newest at bottom)
        interceptQueue.push({
            id: msg.id,
            method: msg.method,
            url: msg.url,
            host: msg.host,
            headers: msg.headers,
            body: msg.body,
            raw: msg.raw,
            itemType: 'request'
        });
        updateInterceptTable();
        
        // Auto-select the newest request if nothing is selected
        if (selectedInterceptIndex === -1) {
            selectedInterceptIndex = interceptQueue.length - 1;
            selectInterceptRequest(selectedInterceptIndex);
            
            // Auto-scroll to show the selected request
            setTimeout(() => {
                const tableContainer = document.querySelector('.top-pane');
                if (tableContainer) {
                    tableContainer.scrollTop = tableContainer.scrollHeight;
                }
            }, 100);
        }
    }
    else if (type === 'intercepted_response') {
        // Check if this response is already in the queue (avoid duplicates)
        const existingIndex = interceptQueue.findIndex(r => r.id === msg.id);
        if (existingIndex >= 0) {
            return; // Already exists, ignore
        }
        
        // Add new response to the END of queue (newest at bottom)
        interceptQueue.push({
            id: msg.id,
            method: msg.method,
            url: msg.url,
            host: msg.host,
            statusCode: msg.status_code,
            headers: msg.response_headers,
            body: msg.response_body,
            raw: msg.raw_response,
            itemType: 'response',
            parentId: msg.parent_id,
            parentRequest: msg.parent_request
        });
        updateInterceptTable();
        
        // Auto-select the newest response if nothing is selected
        if (selectedInterceptIndex === -1) {
            selectedInterceptIndex = interceptQueue.length - 1;
            selectInterceptRequest(selectedInterceptIndex);
            
            // Auto-scroll to show the selected response
            setTimeout(() => {
                const tableContainer = document.querySelector('.top-pane');
                if (tableContainer) {
                    tableContainer.scrollTop = tableContainer.scrollHeight;
                }
            }, 100);
        }
    }
    else if (type === 'forwarded' || type === 'dropped') {
        // Remove from queue
        const removedIndex = interceptQueue.findIndex(r => r.id === msg.id);
        if (removedIndex === -1) {
            // Check if it's a parent_id (response being forwarded)
            const parentIndex = interceptQueue.findIndex(r => r.parentId === msg.id);
            if (parentIndex >= 0) {
                interceptQueue = interceptQueue.filter(r => r.parentId !== msg.id);
                markedForResponseIntercept.delete(msg.id);
                updateInterceptTable();
                updateInterceptResponseButton();
            }
            return;
        }

        const removedItem = interceptQueue[removedIndex];
        interceptQueue = interceptQueue.filter(r => r.id !== msg.id);

        // Remove from marked set if it was marked
        markedForResponseIntercept.delete(msg.id);

        // Adjust selected index if needed
        if (removedIndex === selectedInterceptIndex) {
            // The selected item was removed
            if (interceptQueue.length > 0) {
                // Select the next item, or the last one if we removed the last
                selectedInterceptIndex = Math.min(removedIndex, interceptQueue.length - 1);
                selectInterceptRequest(selectedInterceptIndex);
            } else {
                selectedInterceptIndex = -1;
                clearInterceptEditor();
                updateInterceptTable();
            }
        } else if (removedIndex < selectedInterceptIndex) {
            // An item before the selected one was removed, adjust index
            selectedInterceptIndex--;
            updateInterceptTable();
        } else {
            // An item after the selected one was removed, just update table
            updateInterceptTable();
        }
        updateInterceptResponseButton();
    }
    else if (type === 'queue_cleared') {
        interceptQueue = [];
        selectedInterceptIndex = -1;
        markedForResponseIntercept.clear();
        updateInterceptTable();
        clearInterceptEditor();
        updateInterceptResponseButton();
    }
    else if (type === 'marked_for_response_intercept') {
        markedForResponseIntercept.add(msg.id);
        updateInterceptResponseButton();
    }
    else if (type === 'unmarked_for_response_intercept') {
        markedForResponseIntercept.delete(msg.id);
        updateInterceptResponseButton();
    }
    
    // HISTORY
    else if (type === 'history') {
        historyData = msg.data;
        renderHistory();
    }
    else if (type === 'history_detail') {
        document.getElementById('history-request-headers').innerText = msg.request_headers || 'No headers';
        document.getElementById('history-request-body').innerText = msg.request_body || 'No body';
        document.getElementById('history-response-headers').innerText = msg.response_headers || 'No headers';
        document.getElementById('history-response-body').innerText = msg.response_body || 'No body';
    }
    else if (type === 'history_cleared') {
        historyData = [];
        renderHistory();
        document.getElementById('history-request-headers').innerText = 'Select a request...';
        document.getElementById('history-request-body').innerText = 'No request selected';
        document.getElementById('history-response-headers').innerText = 'Select a request...';
        document.getElementById('history-response-body').innerText = 'No response selected';
    }
    
    // REPEATER
    else if (type === 'repeater_response') {
        if (msg.success) {
            document.getElementById("repeater-status").innerHTML = '<span class="text-green-500">Success</span>';
            document.getElementById("repeater-status-code").innerText = msg.data.status_code;
            document.getElementById("repeater-time").innerText = msg.data.elapsed_time + "s";
            document.getElementById("repeater-size").innerText = msg.data.size + " bytes";
            document.getElementById("repeater-response").innerText = msg.data.body;
        } else {
            document.getElementById("repeater-status").innerHTML = '<span class="text-red-500">Error: ' + msg.error + '</span>';
        }
    }
    
    // INTRUDER
    else if (type === 'intruder_results') {
        intruderResults = msg.results;
        renderIntruderResults(msg.results, msg.total);
    }
    else if (type === 'intruder_stopped') {
        document.getElementById("intruder-progress").innerText = "Attack stopped";
    }
    else if (type === 'payloads') {
        document.getElementById("intruder-payloads").value = msg.payloads.join("\n");
        document.getElementById("intruder-preset").value = "";
    }
    else if (type === 'error') {
        console.error('Server error:', msg.message);
    }
}

// ==================== INTERCEPTOR ====================
function toggleIntercept() {
    interceptEnabled = !interceptEnabled;
    const btn = document.getElementById('intercept-toggle-btn');
    const indicator = document.getElementById('intercept-status');
    
    if (interceptEnabled) {
        btn.innerHTML = 'Intercept is ON';
        btn.classList.add('active');
        indicator.innerHTML = '<span class="intercepting text-green-500">Intercepting Requests...</span>';
    } else {
        btn.innerHTML = 'Intercept is OFF';
        btn.classList.remove('active');
        if (!responseInterceptEnabled) {
            indicator.innerHTML = '';
        }
    }
    
    sendMessage({action: 'toggle_intercept', enabled: interceptEnabled});
}

function toggleResponseIntercept() {
    responseInterceptEnabled = !responseInterceptEnabled;
    const btn = document.getElementById('response-intercept-toggle-btn');
    const indicator = document.getElementById('intercept-status');
    
    if (responseInterceptEnabled) {
        btn.innerHTML = 'Response Intercept is ON';
        btn.classList.add('active');
        indicator.innerHTML = '<span class="intercepting text-blue-500">Intercepting Responses...</span>';
    } else {
        btn.innerHTML = 'Response Intercept is OFF';
        btn.classList.remove('active');
        if (!interceptEnabled) {
            indicator.innerHTML = '';
        }
    }
    
    sendMessage({action: 'toggle_response_intercept', enabled: responseInterceptEnabled});
}

function updateInterceptTable() {
    const tbody = document.getElementById('intercept-table-body');
    const countEl = document.getElementById('queue-count');
    const sizeEl = document.getElementById('queue-size');
    
    sizeEl.textContent = interceptQueue.length;
    
    if (interceptQueue.length > 0) {
        countEl.textContent = interceptQueue.length;
        countEl.classList.remove('hidden');
    } else {
        countEl.classList.add('hidden');
    }
    
    if (interceptQueue.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-center text-gray-500 py-8">No intercepted requests</td></tr>';
        return;
    }
    
    // Display requests: Oldest at top (index 0), newest at bottom
    // The interceptQueue array maintains order - oldest are at the beginning
    tbody.innerHTML = interceptQueue.map((req, index) => {
        let url;
        try {
            url = new URL(req.url);
        } catch (e) {
            url = { hostname: 'unknown', pathname: req.url, search: '' };
        }
        const displayUrl = url.pathname + url.search;
        const truncatedUrl = displayUrl.length > 50 ? displayUrl.substring(0, 50) + '...' : displayUrl;
        
        // Check if it's a response
        const isResponse = req.itemType === 'response';
        const isMarkedForResponse = markedForResponseIntercept.has(req.id);
        const rowClass = isResponse ? 'bg-blue-900/30' : (isMarkedForResponse ? 'bg-purple-900/30' : '');
        const typeLabel = isResponse ? 'RESPONSE' : (isMarkedForResponse ? 'REQUEST â†’' : 'REQUEST');
        const statusDisplay = isResponse ? `<span class="badge ${getStatusColor(req.statusCode)}">${req.statusCode || '-'}</span>` : (isMarkedForResponse ? '<span class="text-purple-400">Intercepting</span>' : 'Waiting');
        
        return `
        <tr class="${index === selectedInterceptIndex ? 'selected' : ''} ${rowClass}" onclick="selectInterceptRequest(${index})">
            <td>${index + 1}</td>
            <td><span class="badge ${getMethodColor(req.method)}">${req.method}</span></td>
            <td>${url.hostname}</td>
            <td class="truncate max-w-xs" title="${displayUrl}">${truncatedUrl}</td>
            <td>${typeLabel} ${statusDisplay}</td>
        </tr>
    `}).join('');
}

function getStatusColor(statusCode) {
    if (!statusCode) return '';
    if (statusCode >= 200 && statusCode < 300) return 'status-2xx';
    if (statusCode >= 300 && statusCode < 400) return 'status-3xx';
    if (statusCode >= 400 && statusCode < 500) return 'status-4xx';
    if (statusCode >= 500) return 'status-5xx';
    return '';
}

function getMethodColor(method) {
    if (method === 'GET') return 'status-2xx';
    if (method === 'POST') return 'status-3xx';
    if (method === 'PUT') return 'status-4xx';
    if (method === 'DELETE') return 'status-5xx';
    return '';
}

function selectInterceptRequest(index) {
    if (index < 0 || index >= interceptQueue.length) {
        clearInterceptEditor();
        updateInterceptResponseButton();
        return;
    }

    selectedInterceptIndex = index;
    const req = interceptQueue[index];
    if (!req) {
        clearInterceptEditor();
        updateInterceptResponseButton();
        return;
    }

    // Check if this request is marked for response interception
    const isMarkedForResponse = markedForResponseIntercept.has(req.id);

    if (req.itemType === 'response') {
        // It's a response - show split view with request and response
        showSplitPane(req);
    } else {
        // It's a request - show single editor
        showSinglePane(req);
    }

    updateInterceptResponseButton();
    updateInterceptTable();
}

function showSinglePane(req) {
    document.getElementById('single-editor-pane').classList.remove('hidden');
    document.getElementById('split-editor-pane').classList.add('hidden');

    const editorTitle = document.getElementById('single-editor-title');
    editorTitle.textContent = 'Request Editor (Raw)';

    let raw = req.raw || buildRawRequest(req);
    document.getElementById('intercept-editor').value = raw;
}

function showSplitPane(resp) {
    // Hide single pane, show split pane
    document.getElementById('single-editor-pane').classList.add('hidden');
    document.getElementById('split-editor-pane').classList.remove('hidden');

    // Use parent request data from response (sent by backend)
    const parentReq = resp.parentRequest;

    // Show request (read-only)
    if (parentReq) {
        const requestRaw = parentReq.raw || buildRawRequest(parentReq);
        document.getElementById('intercept-request-view').value = requestRaw;
    } else {
        document.getElementById('intercept-request-view').value = 'Request not available';
    }

    // Show response (editable)
    let responseRaw = resp.raw || buildRawResponse(resp);
    document.getElementById('intercept-response-editor').value = responseRaw;
}

function updateInterceptResponseButton() {
    const btn = document.getElementById('intercept-response-btn');

    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) {
        btn.disabled = true;
        btn.textContent = 'Intercept Response';
        btn.style.backgroundColor = '#6b7280';
        return;
    }

    const req = interceptQueue[selectedInterceptIndex];

    // Only enable for requests (not responses)
    if (req.itemType === 'response') {
        btn.disabled = true;
        btn.textContent = 'Intercept Response';
        btn.style.backgroundColor = '#6b7280';
        return;
    }

    btn.disabled = false;
    const isMarked = markedForResponseIntercept.has(req.id);

    if (isMarked) {
        btn.textContent = 'Cancel Response Intercept';
        btn.style.backgroundColor = '#ef4444';
        document.getElementById('response-intercept-status').textContent = 'Response will be intercepted';
    } else {
        btn.textContent = 'Intercept Response';
        btn.style.backgroundColor = '#8b5cf6';
        document.getElementById('response-intercept-status').textContent = '';
    }
}

function markForResponseIntercept() {
    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) return;

    const req = interceptQueue[selectedInterceptIndex];
    if (req.itemType === 'response') return;

    const isMarked = markedForResponseIntercept.has(req.id);

    if (isMarked) {
        // Unmark
        markedForResponseIntercept.delete(req.id);
        sendMessage({
            action: 'unmark_for_response_intercept',
            id: req.id
        });
    } else {
        // Mark
        markedForResponseIntercept.add(req.id);
        sendMessage({
            action: 'mark_for_response_intercept',
            id: req.id
        });
    }

    updateInterceptResponseButton();
}

function clearInterceptEditor() {
    const editor = document.getElementById('intercept-editor');
    if (editor) {
        editor.value = '';
    }
    const editorTitle = document.getElementById('single-editor-title');
    if (editorTitle) editorTitle.textContent = 'Request Editor (Raw)';

    // Also clear split pane
    document.getElementById('intercept-request-view').value = '';
    document.getElementById('intercept-response-editor').value = '';

    // Reset to single pane view
    document.getElementById('single-editor-pane').classList.remove('hidden');
    document.getElementById('split-editor-pane').classList.add('hidden');
}

function buildRawRequest(req) {
    const url = new URL(req.url);
    let raw = `${req.method} ${url.pathname}${url.search} HTTP/1.1\n`;
    raw += `Host: ${url.hostname}\n`;
    raw += req.headers;
    if (req.body) {
        raw += `\n\n${req.body}`;
    }
    return raw;
}

function buildRawResponse(resp) {
    let raw = `HTTP/1.1 ${resp.statusCode || 200} OK\n`;
    raw += resp.headers || '';
    if (resp.body) {
        raw += `\n\n${resp.body}`;
    }
    return raw;
}

function parseRawRequest(raw) {
    const lines = raw.split('\n');
    const firstLine = lines[0].trim();
    const parts = firstLine.split(' ');
    const method = parts[0];
    const path = parts[1] || '/';
    
    // Find where body starts
    let bodyStart = -1;
    let headers = [];
    for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === '') {
            bodyStart = i + 1;
            break;
        }
        headers.push(lines[i]);
    }
    
    const body = bodyStart > 0 ? lines.slice(bodyStart).join('\n') : '';
    
    return {
        method: method,
        path: path,
        headers: headers.join('\n'),
        body: body
    };
}

function parseRawResponse(raw) {
    const lines = raw.split('\n');
    const firstLine = lines[0].trim();
    // Parse status line: HTTP/1.1 200 OK
    const statusMatch = firstLine.match(/HTTP\/\d\.\d\s+(\d+)\s+(.*)/);
    const statusCode = statusMatch ? parseInt(statusMatch[1]) : 200;
    
    // Find where body starts
    let bodyStart = -1;
    let headers = [];
    for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === '') {
            bodyStart = i + 1;
            break;
        }
        headers.push(lines[i]);
    }
    
    const body = bodyStart > 0 ? lines.slice(bodyStart).join('\n') : '';
    
    return {
        statusCode: statusCode,
        headers: headers.join('\n'),
        body: body
    };
}

function updateInterceptedRequest() {
    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) {
        alert('No request selected');
        return;
    }
    
    const item = interceptQueue[selectedInterceptIndex];
    const raw = document.getElementById('intercept-editor').value;
    
    if (item.itemType === 'response') {
        // Update response
        const parsed = parseRawResponse(raw);
        item.statusCode = parsed.statusCode;
        item.headers = parsed.headers;
        item.body = parsed.body;
    } else {
        // Update request
        const parsed = parseRawRequest(raw);
        const url = new URL(item.url);
        const newUrl = `${url.protocol}//${url.hostname}${parsed.path}`;
        
        item.method = parsed.method;
        item.url = newUrl;
        item.headers = parsed.headers;
        item.body = parsed.body;
    }
    
    updateInterceptTable();
}

function forwardRequest() {
    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) {
        alert('No request selected');
        return;
    }

    const item = interceptQueue[selectedInterceptIndex];

    // Check if we're in split pane mode (response interception)
    const isSplitPane = !document.getElementById('split-editor-pane').classList.contains('hidden');

    if (isSplitPane && item.itemType === 'response') {
        // Forward response from split pane - send raw format
        const responseRaw = document.getElementById('intercept-response-editor').value;
        sendMessage({
            action: 'forward_response',
            id: item.id,
            response: responseRaw
        });
    } else if (item.itemType === 'response') {
        // Forward response from single pane (fallback) - send raw format
        const responseRaw = document.getElementById('intercept-editor').value;
        sendMessage({
            action: 'forward_response',
            id: item.id,
            response: responseRaw
        });
    } else {
        // Forward request - send raw format
        const requestRaw = document.getElementById('intercept-editor').value;
        sendMessage({
            action: 'forward_request',
            id: item.id,
            request: requestRaw
        });
    }
}

function updateInterceptedResponse() {
    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) {
        alert('No response selected');
        return;
    }

    const item = interceptQueue[selectedInterceptIndex];
    if (item.itemType !== 'response') {
        alert('No response selected');
        return;
    }

    const responseRaw = document.getElementById('intercept-response-editor').value;
    const parsed = parseRawResponse(responseRaw);

    item.statusCode = parsed.statusCode;
    item.headers = parsed.headers;
    item.body = parsed.body;

    updateInterceptTable();
}

function dropRequest() {
    if (selectedInterceptIndex < 0 || selectedInterceptIndex >= interceptQueue.length) {
        alert('No request selected');
        return;
    }
    
    const item = interceptQueue[selectedInterceptIndex];
    
    if (item.itemType === 'response') {
        sendMessage({
            action: 'drop_response',
            id: item.id
        });
    } else {
        sendMessage({
            action: 'drop_request',
            id: item.id
        });
    }
}

function forwardAll() {
    if (interceptQueue.length === 0) return;
    
    // Store all items (requests and responses) to forward
    const itemsToForward = interceptQueue.map(item => {
        let raw;
        // If this item is currently selected, get the latest content from the relevant editor
        if (selectedInterceptIndex !== -1 && interceptQueue[selectedInterceptIndex].id === item.id) {
            if (item.itemType === 'response') {
                raw = document.getElementById('intercept-response-editor').value;
            } else {
                raw = document.getElementById('intercept-editor').value;
            }
        } else {
            // Otherwise use the stored raw content or rebuild it
            if (item.itemType === 'response') {
                raw = item.raw || buildRawResponse(item);
            } else {
                raw = item.raw || buildRawRequest(item);
            }
        }

        return {
            id: item.id,
            type: item.itemType,
            raw: raw
        };
    });
    
    // Immediately clear the local queue to prevent UI inconsistencies
    interceptQueue = [];
    selectedInterceptIndex = -1;
    clearInterceptEditor();
    updateInterceptTable();
    
    sendMessage({
        action: 'forward_all',
        items: itemsToForward
    });
}

function dropAll() {
    if (interceptQueue.length === 0) return;
    
    if (!confirm(`Drop all ${interceptQueue.length} intercepted requests?`)) return;
    
    // Store IDs before clearing
    const idsToDrop = interceptQueue.map(r => r.id);
    
    // Immediately clear the local queue to prevent UI inconsistencies
    interceptQueue = [];
    selectedInterceptIndex = -1;
    clearInterceptEditor();
    updateInterceptTable();
    
    sendMessage({
        action: 'drop_all',
        ids: idsToDrop
    });
}

// ==================== HISTORY ====================
function renderHistory() {
    const search = document.getElementById('history-search').value.toLowerCase();
    let rows = historyData;
    
    if (search.trim() !== '') {
        rows = rows.filter(r => r[2].toLowerCase().includes(search));
    }
    
    const tbody = document.getElementById('history-table');
    tbody.innerHTML = '';
    
    rows.forEach(row => {
        const tr = document.createElement('tr');
        tr.className = 'table-row border-b border-gray-800 cursor-pointer';
        
        let statusClass = '';
        if(row[3] >= 200 && row[3] < 300) statusClass = 'status-2xx';
        else if(row[3] >= 300 && row[3] < 400) statusClass = 'status-3xx';
        else if(row[3] >= 400 && row[3] < 500) statusClass = 'status-4xx';
        else if(row[3] >= 500) statusClass = 'status-5xx';
        
        tr.innerHTML = `
            <td class="p-2">${row[0]}</td>
            <td class="p-2">${row[1]}</td>
            <td class="p-2"><span class="badge ${statusClass}">${row[3]}</span></td>
            <td class="p-2 truncate max-w-xs">${row[2]}</td>
        `;
        
        tr.onclick = () => selectHistoryItem(row[0]);
        tbody.appendChild(tr);
    });
}

function filterHistory() {
    renderHistory();
}

function selectHistoryItem(id) {
    selectedHistoryId = id;
    sendMessage({action: 'get_history_detail', id: id});
}

function clearHistory() {
    if (!confirm('Clear all history?')) return;
    sendMessage({action: 'clear_history'});
}

function sendHistoryToRepeater() {
    if (!selectedHistoryId) {
        alert('Select a request first');
        return;
    }
    // TODO: Implement sending to repeater
    alert('Feature coming soon');
}

// ==================== REPEATER ====================
function sendRepeaterRequest() {
    const method = document.getElementById('repeater-method').value;
    const url = document.getElementById('repeater-url').value;
    let headers = {};
    
    try {
        headers = JSON.parse(document.getElementById('repeater-headers').value);
    } catch (e) {
        alert('Invalid headers JSON!');
        return;
    }
    
    const body = document.getElementById('repeater-body').value;
    
    document.getElementById('repeater-status').innerHTML = '<span class="loader"></span> Sending...';
    
    sendMessage({
        action: 'repeater_send',
        request: {
            method: method,
            url: url,
            headers: headers,
            body: body,
            timeout: 30,
            follow_redirects: true
        }
    });
}

function clearRepeater() {
    document.getElementById('repeater-url').value = '';
    document.getElementById('repeater-headers').value = '{\n  "Content-Type": "application/json"\n}';
    document.getElementById('repeater-body').value = '';
    document.getElementById('repeater-response').innerText = '';
    document.getElementById('repeater-status-code').innerText = '-';
    document.getElementById('repeater-time').innerText = '-';
    document.getElementById('repeater-size').innerText = '-';
}

function sendToIntruder() {
    showTab('intruder');
    document.getElementById('intruder-method').value = document.getElementById('repeater-method').value;
    document.getElementById('intruder-url').value = document.getElementById('repeater-url').value;
    document.getElementById('intruder-headers').value = document.getElementById('repeater-headers').value;
    document.getElementById('intruder-body').value = document.getElementById('repeater-body').value;
}

// ==================== INTRUDER ====================
function loadPayloadPreset() {
    const preset = document.getElementById('intruder-preset').value;
    if (!preset) return;
    
    sendMessage({
        action: 'get_payloads',
        payload_type: preset,
        start: 0,
        end: 100,
        step: 1
    });
}

function startIntruderAttack() {
    const attackType = document.getElementById('intruder-attack-type').value;
    const method = document.getElementById('intruder-method').value;
    const url = document.getElementById('intruder-url').value;
    const body = document.getElementById('intruder-body').value;
    const threads = parseInt(document.getElementById('intruder-threads').value) || 10;
    
    let headers = {};
    try {
        headers = JSON.parse(document.getElementById('intruder-headers').value);
    } catch (e) {
        alert('Invalid headers JSON!');
        return;
    }
    
    const payloadsText = document.getElementById('intruder-payloads').value;
    const payloads = payloadsText.split('\n').filter(p => p.trim());
    
    if (payloads.length === 0) {
        alert('Please enter payloads!');
        return;
    }
    
    document.getElementById('intruder-results').innerHTML = '';
    document.getElementById('intruder-response-preview').innerText = '';
    document.getElementById('intruder-summary').classList.add('hidden');
    intruderResults = [];
    
    document.getElementById('intruder-start-btn').disabled = true;
    document.getElementById('intruder-start-btn').innerText = 'Running...';
    document.getElementById('intruder-progress').innerText = 'Starting attack...';
    
    sendMessage({
        action: 'intruder_attack',
        method: method,
        url: url,
        headers: headers,
        body: body,
        attack_type: attackType,
        payloads: payloads,
        threads: threads,
        timeout: 30
    });
}

function renderIntruderResults(results, total) {
    const tbody = document.getElementById('intruder-results');
    tbody.innerHTML = '';
    
    results.forEach((r, i) => {
        const tr = document.createElement('tr');
        tr.className = 'result-row border-b border-gray-800 cursor-pointer';
        
        let statusClass = '';
        if(r.status_code >= 200 && r.status_code < 300) statusClass = 'status-2xx';
        else if(r.status_code >= 300 && r.status_code < 400) statusClass = 'status-3xx';
        else if(r.status_code >= 400 && r.status_code < 500) statusClass = 'status-4xx';
        else if(r.status_code >= 500) statusClass = 'status-5xx';
        
        tr.innerHTML = `
            <td class="p-2">${i + 1}</td>
            <td class="p-2 truncate max-w-xs">${r.payload}</td>
            <td class="p-2"><span class="badge ${statusClass}">${r.status_code || 'ERR'}</span></td>
            <td class="p-2">${r.length}</td>
            <td class="p-2">${r.time}s</td>
        `;
        
        tr.onclick = () => showIntruderResult(i, tr);
        tbody.appendChild(tr);
    });
    
    document.getElementById('intruder-progress').innerText = `Completed: ${total} requests`;
    document.getElementById('intruder-summary').classList.remove('hidden');
    
    const errors = results.filter(r => r.error).length;
    const avgLength = results.length > 0 ? Math.round(results.reduce((a, r) => a + r.length, 0) / results.length) : 0;
    const avgTime = results.length > 0 ? (results.reduce((a, r) => a + r.time, 0) / results.length).toFixed(3) : 0;
    
    document.getElementById('intruder-summary-text').innerText = 
        `Total: ${total} | Errors: ${errors} | Avg Length: ${avgLength} bytes | Avg Time: ${avgTime}s`;
    
    document.getElementById('intruder-start-btn').disabled = false;
    document.getElementById('intruder-start-btn').innerText = 'Start Attack';
}

function showIntruderResult(index, row) {
    document.querySelectorAll('.result-row').forEach(r => r.classList.remove('selected'));
    row.classList.add('selected');
    
    const result = intruderResults[index];
    if (result) {
        document.getElementById('intruder-response-preview').innerText = result.error || 'No response data';
    }
}

function stopIntruderAttack() {
    sendMessage({action: 'intruder_stop'});
}

// ==================== UTILS ====================
function showTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
    document.getElementById('content-' + tabName).classList.add('active');
    document.getElementById('tab-' + tabName).classList.add('active');
}

function copyContent(id) {
    const el = document.getElementById(id);
    navigator.clipboard.writeText(el.innerText);
}

// Initialize
connectWebSocket();
</script>

</body>
</html>
